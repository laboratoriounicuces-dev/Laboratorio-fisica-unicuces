<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Elasticidad - Laboratorio Virtual de Física</title>
    <style>
        :root {
            --deep-navy: #0f0c29;
            --dark-purple: #302b63;
            --medium-purple: #4a3f8c;
            --light-purple: #6a52b5;
            --electric-blue: #2196f3;
            --light-blue: #64b5f6;
            --lavender: #b39ddb;
            --white: #ffffff;
            --light-gray: #f5f7ff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--deep-navy), var(--dark-purple));
            color: var(--white);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: linear-gradient(135deg, var(--medium-purple), var(--dark-purple));
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--light-purple);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, var(--light-blue), var(--lavender));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            color: var(--lavender);
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .simulation-panel {
            flex: 1;
            min-width: 300px;
            background: linear-gradient(145deg, var(--dark-purple), var(--medium-purple));
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--light-purple);
        }
        
        .controls-panel {
            flex: 1;
            min-width: 300px;
            background: linear-gradient(145deg, var(--dark-purple), var(--medium-purple));
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--light-purple);
        }
        
        .panel-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--electric-blue);
            color: var(--light-blue);
        }
        
        canvas {
            width: 100%;
            height: 400px;
            background: rgba(15, 12, 41, 0.6);
            border-radius: 10px;
            display: block;
            border: 1px solid var(--light-purple);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--lavender);
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, var(--light-purple), var(--electric-blue));
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--light-blue);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .value-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            opacity: 0.8;
            color: var(--lavender);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, var(--electric-blue), var(--light-purple));
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button.reset {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
        }
        
        button.export {
            background: linear-gradient(to right, #2ecc71, #27ae60);
        }
        
        .simulation-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .sim-option {
            flex: 1;
            min-width: 120px;
            padding: 12px;
            text-align: center;
            background: linear-gradient(145deg, var(--medium-purple), var(--dark-purple));
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--light-purple);
            color: var(--lavender);
        }
        
        .sim-option.active {
            background: linear-gradient(to right, var(--electric-blue), var(--light-purple));
            color: var(--white);
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(33, 150, 243, 0.4);
        }
        
        .data-panel {
            background: linear-gradient(145deg, var(--dark-purple), var(--medium-purple));
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            margin-top: 20px;
            border: 1px solid var(--light-purple);
        }
        
        .data-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .data-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }
        
        .data-item {
            background: rgba(15, 12, 41, 0.6);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--light-purple);
        }
        
        .data-label {
            font-size: 0.85rem;
            margin-bottom: 5px;
            color: var(--lavender);
        }
        
        .data-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--light-blue);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .explanation-panel {
            background: linear-gradient(145deg, var(--dark-purple), var(--medium-purple));
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            margin-top: 20px;
            border: 1px solid var(--light-purple);
        }
        
        .explanation-content {
            background: rgba(15, 12, 41, 0.6);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--light-purple);
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .formula {
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 5px;
            margin: 10px 0;
            display: inline-block;
            color: var(--light-blue);
        }
        
        .data-log {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(15, 12, 41, 0.6);
            border-radius: 8px;
            padding: 10px;
            border: 1px solid var(--light-purple);
        }
        
        .data-log table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        
        .data-log th, .data-log td {
            padding: 6px 8px;
            text-align: center;
            border-bottom: 1px solid var(--light-purple);
        }
        
        .data-log th {
            background: rgba(74, 63, 140, 0.5);
            color: var(--lavender);
            position: sticky;
            top: 0;
        }
        
        .export-options {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
            color: var(--lavender);
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .data-display {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
            
            .data-value {
                font-size: 1.1rem;
            }
            
            .export-options {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Simulador de Elasticidad - Física II</h1>
            <p class="subtitle">Explora los principios de la elasticidad, la ley de Hooke y el movimiento armónico simple</p>
        </header>
        
        <div class="simulation-selector">
            <div class="sim-option active" data-sim="hooke">Ley de Hooke</div>
            <div class="sim-option" data-sim="series">Resortes en Serie</div>
            <div class="sim-option" data-sim="parallel">Resortes en Paralelo</div>
            <div class="sim-option" data-sim="oscillation">Oscilación Armónica</div>
            <div class="sim-option" data-sim="energy">Energía en el Sistema</div>
        </div>
        
        <div class="main-content">
            <div class="simulation-panel">
                <h2 class="panel-title">Simulación</h2>
                <canvas id="simulationCanvas"></canvas>
            </div>
            
            <div class="controls-panel">
                <h2 class="panel-title">Controles</h2>
                
                <div class="control-group">
                    <label for="springConstant">Constante del Resorte (k):</label>
                    <input type="range" id="springConstant" min="50" max="500" value="200">
                    <div class="value-display">
                        <span>Baja Rigidez</span>
                        <span id="springConstantValue">200 N/m</span>
                        <span>Alta Rigidez</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="mass">Masa (m):</label>
                    <input type="range" id="mass" min="1" max="20" value="5">
                    <div class="value-display">
                        <span>Ligera</span>
                        <span id="massValue">5 kg</span>
                        <span>Pesada</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="damping">Amortiguamiento (β):</label>
                    <input type="range" id="damping" min="0" max="10" value="1">
                    <div class="value-display">
                        <span>Bajo</span>
                        <span id="dampingValue">1 N·s/m</span>
                        <span>Alto</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="displacement">Desplazamiento Inicial (x₀):</label>
                    <input type="range" id="displacement" min="-100" max="100" value="50">
                    <div class="value-display">
                        <span>-100 cm</span>
                        <span id="displacementValue">50 cm</span>
                        <span>100 cm</span>
                    </div>
                </div>
                
                <div class="button-group">
                    <button id="startBtn">Iniciar</button>
                    <button id="pauseBtn">Pausar</button>
                    <button id="resetBtn" class="reset">Reiniciar</button>
                </div>
            </div>
        </div>
        
        <div class="data-panel">
            <div class="data-header">
                <h2 class="panel-title">Datos en Tiempo Real</h2>
                <div class="export-options">
                    <button id="exportBtn" class="export">Exportar a Excel</button>
                    <button id="clearDataBtn" class="reset">Limpiar Datos</button>
                </div>
            </div>
            <div class="data-display">
                <div class="data-item">
                    <div class="data-label">Fuerza Restauradora</div>
                    <div class="data-value" id="forceValue">0.00 N</div>
                </div>
                <div class="data-item">
                    <div class="data-label">Energía Potencial</div>
                    <div class="data-value" id="potentialEnergyValue">0.00 J</div>
                </div>
                <div class="data-item">
                    <div class="data-label">Energía Cinética</div>
                    <div class="data-value" id="kineticEnergyValue">0.00 J</div>
                </div>
                <div class="data-item">
                    <div class="data-label">Energía Total</div>
                    <div class="data-value" id="totalEnergyValue">0.00 J</div>
                </div>
                <div class="data-item">
                    <div class="data-label">Periodo</div>
                    <div class="data-value" id="periodValue">0.00 s</div>
                </div>
                <div class="data-item">
                    <div class="data-label">Frecuencia</div>
                    <div class="data-value" id="frequencyValue">0.00 Hz</div>
                </div>
            </div>
            
            <div class="data-log">
                <table id="dataTable">
                    <thead>
                        <tr>
                            <th>Tiempo (s)</th>
                            <th>Desplazamiento (m)</th>
                            <th>Velocidad (m/s)</th>
                            <th>Fuerza (N)</th>
                            <th>Energía Pot. (J)</th>
                            <th>Energía Cin. (J)</th>
                            <th>Energía Total (J)</th>
                        </tr>
                    </thead>
                    <tbody id="dataTableBody">
                        <!-- Los datos se agregarán aquí dinámicamente -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <div class="explanation-panel">
            <h2 class="panel-title">Explicación Física</h2>
            <div class="explanation-content" id="explanationContent">
                <p><strong>Ley de Hooke:</strong> Establece que la fuerza necesaria para estirar o comprimir un resorte es directamente proporcional a la distancia de deformación.</p>
                <p class="formula">F = -k · x</p>
                <p>Donde F es la fuerza restauradora, k es la constante del resorte (rigidez) y x es el desplazamiento desde la posición de equilibrio.</p>
            </div>
        </div>
        
        <footer>
            <p>Simulador de Elasticidad - Física II | Creado para demostrar conceptos de elasticidad y movimiento armónico</p>
        </footer>
    </div>

    <script>
        // =============================================
        // SIMULADOR DE ELASTICIDAD - OPTIMIZADO
        // =============================================
        
        // Configuración global para integración con el laboratorio principal
        window.elasticitySimulator = {
            init: function() {
                console.log('Simulador de Elasticidad inicializado');
                this.setupEventListeners();
                this.resizeCanvas();
                this.updateExplanation();
                this.draw();
            },
            
            cleanup: function() {
                console.log('Limpiando recursos del simulador de elasticidad');
                this.simulation.running = false;
                cancelAnimationFrame(this.animationFrameId);
                
                // Limpiar event listeners
                const events = ['resize', 'input', 'click'];
                events.forEach(event => {
                    window.removeEventListener(event, this.eventHandlers[event]);
                });
                
                // Limpiar referencias
                this.ctx = null;
                this.canvas = null;
            },
            
            eventHandlers: {}
        };

        // Elementos del DOM
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const explanationContent = document.getElementById('explanationContent');
        const dataTableBody = document.getElementById('dataTableBody');
        const exportBtn = document.getElementById('exportBtn');
        const clearDataBtn = document.getElementById('clearDataBtn');
        
        // Variables de animación
        let animationFrameId = null;
        let lastTime = 0;
        
        // Ajustar tamaño del canvas
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        // Variables de simulación optimizadas
        const simulation = {
            running: false,
            time: 0,
            currentSim: 'hooke',
            spring: {
                k: 200,
                naturalLength: 150,
                currentLength: 200,
                displacement: 0.5,
                mass: 5,
                damping: 1,
                velocity: 0,
                equilibrium: 0
            },
            springsSeries: [
                { k: 200, length: 100, displacement: 0 },
                { k: 200, length: 100, displacement: 0 }
            ],
            springsParallel: [
                { k: 200, length: 150, displacement: 0 },
                { k: 200, length: 150, displacement: 0 }
            ],
            dataLog: [],
            logInterval: 0.1,
            lastLogTime: 0
        };
        
        // Cache de elementos DOM para mejor performance
        const DOM = {
            sliders: {
                springConstant: document.getElementById('springConstant'),
                mass: document.getElementById('mass'),
                damping: document.getElementById('damping'),
                displacement: document.getElementById('displacement')
            },
            values: {
                springConstant: document.getElementById('springConstantValue'),
                mass: document.getElementById('massValue'),
                damping: document.getElementById('dampingValue'),
                displacement: document.getElementById('displacementValue'),
                force: document.getElementById('forceValue'),
                potentialEnergy: document.getElementById('potentialEnergyValue'),
                kineticEnergy: document.getElementById('kineticEnergyValue'),
                totalEnergy: document.getElementById('totalEnergyValue'),
                period: document.getElementById('periodValue'),
                frequency: document.getElementById('frequencyValue')
            },
            buttons: {
                start: document.getElementById('startBtn'),
                pause: document.getElementById('pauseBtn'),
                reset: document.getElementById('resetBtn'),
                export: document.getElementById('exportBtn'),
                clearData: document.getElementById('clearDataBtn')
            }
        };
        
        // Explicaciones para cada simulación
        const explanations = {
            hooke: `
                <p><strong>Ley de Hooke:</strong> Establece que la fuerza necesaria para estirar o comprimir un resorte es directamente proporcional a la distancia de deformación.</p>
                <p class="formula">F = -k · x</p>
                <p>Donde F es la fuerza restauradora, k es la constante del resorte (rigidez) y x es el desplazamiento desde la posición de equilibrio.</p>
                <p><strong>¿Por qué este resultado?</strong> Al aumentar la constante del resorte (k), la fuerza restauradora será mayor para el mismo desplazamiento, haciendo que el sistema sea más rígido y oscile más rápido.</p>
            `,
            series: `
                <p><strong>Resortes en Serie:</strong> Cuando los resortes se conectan en serie, la constante equivalente del sistema es menor que la de cualquier resorte individual.</p>
                <p class="formula">1/k<sub>eq</sub> = 1/k<sub>1</sub> + 1/k<sub>2</sub> + ...</p>
                <p>Esto significa que el sistema combinado es más flexible que los resortes individuales.</p>
                <p><strong>¿Por qué este resultado?</strong> Al conectar resortes en serie, la fuerza se transmite a través de todos ellos, pero cada uno se deforma individualmente. La deformación total es la suma de las deformaciones individuales, resultando en un sistema más blando.</p>
            `,
            parallel: `
                <p><strong>Resortes en Paralelo:</strong> Cuando los resortes se conectan en paralelo, la constante equivalente del sistema es la suma de las constantes individuales.</p>
                <p class="formula">k<sub>eq</sub> = k<sub>1</sub> + k<sub>2</sub> + ...</p>
                <p>Esto significa que el sistema combinado es más rígido que los resortes individuales.</p>
                <p><strong>¿Por qué este resultado?</strong> Al conectar resortes en paralelo, la fuerza se distribuye entre ellos, pero todos experimentan la misma deformación. Esto resulta en un sistema más rígido que los resortes individuales.</p>
            `,
            oscillation: `
                <p><strong>Oscilación Armónica:</strong> Un sistema masa-resorte describe un movimiento armónico simple cuando no hay amortiguamiento.</p>
                <p class="formula">x(t) = A · cos(ωt + φ)</p>
                <p>Donde A es la amplitud, ω es la frecuencia angular (√(k/m)), y φ es la fase inicial.</p>
                <p><strong>¿Por qué este resultado?</strong> La energía se intercambia continuamente entre energía potencial (resorte comprimido/estirado) y energía cinética (masa en movimiento). El amortiguamiento introduce una fuerza disipativa que gradualmente reduce la amplitud de oscilación.</p>
            `,
            energy: `
                <p><strong>Conservación de Energía:</strong> En un sistema ideal sin amortiguamiento, la energía total se conserva.</p>
                <p class="formula">E<sub>total</sub> = E<sub>cinética</sub> + E<sub>potencial</sub> = ½mv² + ½kx²</p>
                <p>La energía cinética es máxima cuando la masa pasa por la posición de equilibrio, y la energía potencial es máxima en los puntos de máxima deformación.</p>
                <p><strong>¿Por qué este resultado?</strong> El gráfico muestra cómo la energía se transforma continuamente entre formas cinética y potencial. Con amortiguamiento, la energía total disminuye gradualmente debido a la disipación por fricción.</p>
            `
        };
        
        // =============================================
        // FUNCIONES DE CONFIGURACIÓN
        // =============================================
        
        function setupEventListeners() {
            // Event listeners para sliders
            DOM.sliders.springConstant.addEventListener('input', handleSpringConstantChange);
            DOM.sliders.mass.addEventListener('input', handleMassChange);
            DOM.sliders.damping.addEventListener('input', handleDampingChange);
            DOM.sliders.displacement.addEventListener('input', handleDisplacementChange);
            
            // Event listeners para botones
            DOM.buttons.start.addEventListener('click', startSimulation);
            DOM.buttons.pause.addEventListener('click', pauseSimulation);
            DOM.buttons.reset.addEventListener('click', resetSimulation);
            DOM.buttons.export.addEventListener('click', exportData);
            DOM.buttons.clearData.addEventListener('click', clearData);
            
            // Event listeners para selección de simulación
            document.querySelectorAll('.sim-option').forEach(option => {
                option.addEventListener('click', handleSimulationChange);
            });
            
            // Event listener para resize
            window.addEventListener('resize', resizeCanvas);
            
            // Guardar referencias para cleanup
            window.elasticitySimulator.eventHandlers = {
                resize: resizeCanvas,
                input: handleSpringConstantChange, // Solo como ejemplo
                click: handleSimulationChange // Solo como ejemplo
            };
        }
        
        // =============================================
        // MANEJADORES DE EVENTOS
        // =============================================
        
        function handleSpringConstantChange(e) {
            simulation.spring.k = parseInt(e.target.value);
            DOM.values.springConstant.textContent = `${e.target.value} N/m`;
        }
        
        function handleMassChange(e) {
            simulation.spring.mass = parseInt(e.target.value);
            DOM.values.mass.textContent = `${e.target.value} kg`;
        }
        
        function handleDampingChange(e) {
            simulation.spring.damping = parseInt(e.target.value);
            DOM.values.damping.textContent = `${e.target.value} N·s/m`;
        }
        
        function handleDisplacementChange(e) {
            simulation.spring.displacement = parseInt(e.target.value) / 100;
            DOM.values.displacement.textContent = `${e.target.value} cm`;
        }
        
        function handleSimulationChange(e) {
            document.querySelectorAll('.sim-option').forEach(opt => opt.classList.remove('active'));
            e.currentTarget.classList.add('active');
            simulation.currentSim = e.currentTarget.getAttribute('data-sim');
            updateExplanation();
            resetSimulation();
        }
        
        function startSimulation() {
            simulation.running = true;
            if (!animationFrameId) {
                animate();
            }
        }
        
        function pauseSimulation() {
            simulation.running = false;
        }
        
        // =============================================
        // FUNCIONES DE SIMULACIÓN
        // =============================================
        
        function resetSimulation() {
            simulation.time = 0;
            simulation.spring.velocity = 0;
            simulation.spring.displacement = DOM.sliders.displacement.value / 100;
            simulation.dataLog = [];
            dataTableBody.innerHTML = '';
            simulation.lastLogTime = 0;
            draw();
        }
        
        function animate(currentTime = 0) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            const clampedDeltaTime = Math.min(deltaTime, 0.1);
            
            updateSimulation(clampedDeltaTime);
            draw();
            
            if (simulation.running) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                animationFrameId = null;
            }
        }
        
        function updateSimulation(deltaTime) {
            if (!simulation.running) return;
            
            simulation.time += deltaTime;
            
            switch(simulation.currentSim) {
                case 'hooke':
                case 'oscillation':
                case 'energy':
                    updateSpringMotion(deltaTime);
                    break;
                case 'series':
                    updateSpringsSeries(deltaTime);
                    break;
                case 'parallel':
                    updateSpringsParallel(deltaTime);
                    break;
            }
            
            logData();
            updateDisplay();
        }
        
        function updateSpringMotion(deltaTime) {
            const spring = simulation.spring;
            const force = -spring.k * spring.displacement;
            const dampingForce = -spring.damping * spring.velocity;
            const netForce = force + dampingForce;
            const acceleration = netForce / spring.mass;
            
            spring.velocity += acceleration * deltaTime;
            spring.displacement += spring.velocity * deltaTime;
            spring.currentLength = spring.naturalLength + spring.displacement * 100;
        }
        
        function updateSpringsSeries(deltaTime) {
            const spring1 = simulation.springsSeries[0];
            const spring2 = simulation.springsSeries[1];
            const k_eq = 1 / (1/spring1.k + 1/spring2.k);
            
            const force = -k_eq * simulation.spring.displacement;
            const dampingForce = -simulation.spring.damping * simulation.spring.velocity;
            const netForce = force + dampingForce;
            const acceleration = netForce / simulation.spring.mass;
            
            simulation.spring.velocity += acceleration * deltaTime;
            simulation.spring.displacement += simulation.spring.velocity * deltaTime;
            
            const totalForce = -k_eq * simulation.spring.displacement;
            spring1.displacement = totalForce / spring1.k;
            spring2.displacement = totalForce / spring2.k;
            
            spring1.length = 100 + spring1.displacement * 100;
            spring2.length = 100 + spring2.displacement * 100;
        }
        
        function updateSpringsParallel(deltaTime) {
            const spring1 = simulation.springsParallel[0];
            const spring2 = simulation.springsParallel[1];
            const k_eq = spring1.k + spring2.k;
            
            const force = -k_eq * simulation.spring.displacement;
            const dampingForce = -simulation.spring.damping * simulation.spring.velocity;
            const netForce = force + dampingForce;
            const acceleration = netForce / simulation.spring.mass;
            
            simulation.spring.velocity += acceleration * deltaTime;
            simulation.spring.displacement += simulation.spring.velocity * deltaTime;
            
            spring1.displacement = simulation.spring.displacement;
            spring2.displacement = simulation.spring.displacement;
            
            spring1.length = 150 + spring1.displacement * 100;
            spring2.length = 150 + spring2.displacement * 100;
        }
        
        // =============================================
        // FUNCIONES DE VISUALIZACIÓN
        // =============================================
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(15, 12, 41, 0.6)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            switch(simulation.currentSim) {
                case 'hooke':
                case 'oscillation':
                case 'energy':
                    drawSingleSpring();
                    break;
                case 'series':
                    drawSpringsSeries();
                    break;
                case 'parallel':
                    drawSpringsParallel();
                    break;
            }
            
            drawInfo();
        }
        
        function drawSingleSpring() {
            const spring = simulation.spring;
            const centerX = canvas.width / 2;
            const topY = 50;
            const bottomY = topY + spring.currentLength;
            
            ctx.fillStyle = '#8c7ae6';
            ctx.beginPath();
            ctx.arc(centerX, topY, 10, 0, Math.PI * 2);
            ctx.fill();
            
            drawSpring(centerX, topY, centerX, bottomY, 20, 10);
            
            ctx.fillStyle = '#64b5f6';
            ctx.fillRect(centerX - 30, bottomY, 60, 30);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${spring.mass} kg`, centerX, bottomY + 45);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(centerX - 100, topY + spring.naturalLength);
            ctx.lineTo(centerX + 100, topY + spring.naturalLength);
            ctx.stroke();
            ctx.setLineDash([]);
            
            if (Math.abs(spring.displacement) > 0.01) {
                const displacementY = topY + spring.naturalLength;
                ctx.strokeStyle = '#ff9800';
                ctx.beginPath();
                ctx.moveTo(centerX + 50, displacementY);
                ctx.lineTo(centerX + 50, bottomY);
                ctx.stroke();
                
                ctx.fillStyle = '#ff9800';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`x = ${(spring.displacement * 100).toFixed(1)} cm`, centerX + 60, (displacementY + bottomY) / 2);
            }
        }
        
        function drawSpringsSeries() {
            const spring1 = simulation.springsSeries[0];
            const spring2 = simulation.springsSeries[1];
            const centerX = canvas.width / 2;
            const topY = 50;
            const middleY = topY + spring1.length;
            const bottomY = middleY + spring2.length;
            
            ctx.fillStyle = '#8c7ae6';
            ctx.beginPath();
            ctx.arc(centerX, topY, 10, 0, Math.PI * 2);
            ctx.fill();
            
            drawSpring(centerX, topY, centerX, middleY, 15, 8);
            
            ctx.fillStyle = '#b39ddb';
            ctx.beginPath();
            ctx.arc(centerX, middleY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            drawSpring(centerX, middleY, centerX, bottomY, 15, 8);
            
            ctx.fillStyle = '#64b5f6';
            ctx.fillRect(centerX - 30, bottomY, 60, 30);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${simulation.spring.mass} kg`, centerX, bottomY + 45);
            
            ctx.fillStyle = '#b39ddb';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`k₁ = ${spring1.k} N/m`, centerX - 80, (topY + middleY) / 2);
            ctx.fillText(`k₂ = ${spring2.k} N/m`, centerX - 80, (middleY + bottomY) / 2);
        }
        
        function drawSpringsParallel() {
            const spring1 = simulation.springsParallel[0];
            const spring2 = simulation.springsParallel[1];
            const centerX = canvas.width / 2;
            const topY = 50;
            const bottomY = topY + spring1.length;
            
            ctx.fillStyle = '#8c7ae6';
            ctx.beginPath();
            ctx.arc(centerX - 40, topY, 10, 0, Math.PI * 2);
            ctx.arc(centerX + 40, topY, 10, 0, Math.PI * 2);
            ctx.fill();
            
            drawSpring(centerX - 40, topY, centerX - 40, bottomY, 15, 8);
            drawSpring(centerX + 40, topY, centerX + 40, bottomY, 15, 8);
            
            ctx.fillStyle = '#64b5f6';
            ctx.fillRect(centerX - 70, bottomY, 140, 30);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${simulation.spring.mass} kg`, centerX, bottomY + 45);
            
            ctx.fillStyle = '#b39ddb';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`k₁ = ${spring1.k} N/m`, centerX - 40, (topY + bottomY) / 2 - 20);
            ctx.fillText(`k₂ = ${spring2.k} N/m`, centerX + 40, (topY + bottomY) / 2 - 20);
        }
        
        function drawSpring(x1, y1, x2, y2, coils, amplitude) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            
            ctx.save();
            ctx.translate(x1, y1);
            ctx.rotate(angle);
            
            ctx.strokeStyle = '#b39ddb';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            
            const coilLength = distance / coils;
            for (let i = 0; i < coils; i++) {
                const x = (i + 0.5) * coilLength;
                const y = amplitude * (i % 2 === 0 ? 1 : -1);
                ctx.lineTo(x, y);
            }
            
            ctx.lineTo(distance, 0);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawInfo() {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            
            const info = [
                `Tiempo: ${simulation.time.toFixed(2)} s`,
                `Desplazamiento: ${(simulation.spring.displacement * 100).toFixed(1)} cm`,
                `Velocidad: ${(simulation.spring.velocity * 100).toFixed(1)} cm/s`,
                `Fuerza: ${calculateForce().toFixed(2)} N`
            ];
            
            info.forEach((text, index) => {
                ctx.fillText(text, 20, canvas.height - 80 + index * 20);
            });
            
            if (simulation.currentSim === 'energy') {
                drawEnergyGraph();
            }
        }
        
        function drawEnergyGraph() {
            const graphWidth = 300;
            const graphHeight = 100;
            const graphX = canvas.width - graphWidth - 20;
            const graphY = canvas.height - graphHeight - 20;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.strokeRect(graphX, graphY, graphWidth, graphHeight);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(graphX, graphY, graphWidth, graphHeight);
            
            const energies = calculateEnergies();
            const maxEnergy = Math.max(energies.potential + energies.kinetic, 1);
            
            const potentialHeight = (energies.potential / maxEnergy) * graphHeight;
            const kineticHeight = (energies.kinetic / maxEnergy) * graphHeight;
            
            ctx.fillStyle = 'rgba(33, 150, 243, 0.7)';
            ctx.fillRect(graphX + 50, graphY + graphHeight - potentialHeight, 40, potentialHeight);
            
            ctx.fillStyle = 'rgba(76, 175, 80, 0.7)';
            ctx.fillRect(graphX + 120, graphY + graphHeight - kineticHeight, 40, kineticHeight);
            
            ctx.fillStyle = 'rgba(156, 39, 176, 0.7)';
            ctx.fillRect(graphX + 190, graphY + graphHeight - (energies.total / maxEnergy) * graphHeight, 40, (energies.total / maxEnergy) * graphHeight);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('E. Pot.', graphX + 70, graphY + graphHeight + 15);
            ctx.fillText('E. Cin.', graphX + 140, graphY + graphHeight + 15);
            ctx.fillText('E. Total', graphX + 210, graphY + graphHeight + 15);
        }
        
        // =============================================
        // FUNCIONES DE CÁLCULO
        // =============================================
        
        function calculateForce() {
            return -simulation.spring.k * simulation.spring.displacement;
        }
        
        function calculateEnergies() {
            const potential = 0.5 * simulation.spring.k * Math.pow(simulation.spring.displacement, 2);
            const kinetic = 0.5 * simulation.spring.mass * Math.pow(simulation.spring.velocity, 2);
            const total = potential + kinetic;
            
            return { potential, kinetic, total };
        }
        
        function calculatePeriod() {
            return 2 * Math.PI * Math.sqrt(simulation.spring.mass / simulation.spring.k);
        }
        
        function calculateFrequency() {
            return 1 / calculatePeriod();
        }
        
        // =============================================
        // FUNCIONES DE DATOS Y EXPORTACIÓN
        // =============================================
        
        function logData() {
            if (simulation.time - simulation.lastLogTime >= simulation.logInterval) {
                const energies = calculateEnergies();
                const dataPoint = {
                    time: simulation.time,
                    displacement: simulation.spring.displacement,
                    velocity: simulation.spring.velocity,
                    force: calculateForce(),
                    potentialEnergy: energies.potential,
                    kineticEnergy: energies.kinetic,
                    totalEnergy: energies.total
                };
                
                simulation.dataLog.push(dataPoint);
                simulation.lastLogTime = simulation.time;
                
                addDataToTable(dataPoint);
            }
        }
        
        function addDataToTable(data) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${data.time.toFixed(2)}</td>
                <td>${data.displacement.toFixed(3)}</td>
                <td>${data.velocity.toFixed(3)}</td>
                <td>${data.force.toFixed(3)}</td>
                <td>${data.potentialEnergy.toFixed(3)}</td>
                <td>${data.kineticEnergy.toFixed(3)}</td>
                <td>${data.totalEnergy.toFixed(3)}</td>
            `;
            dataTableBody.appendChild(row);
            
            if (dataTableBody.children.length > 20) {
                dataTableBody.removeChild(dataTableBody.firstChild);
            }
        }
        
        function updateDisplay() {
            const energies = calculateEnergies();
            
            DOM.values.force.textContent = `${calculateForce().toFixed(2)} N`;
            DOM.values.potentialEnergy.textContent = `${energies.potential.toFixed(2)} J`;
            DOM.values.kineticEnergy.textContent = `${energies.kinetic.toFixed(2)} J`;
            DOM.values.totalEnergy.textContent = `${energies.total.toFixed(2)} J`;
            DOM.values.period.textContent = `${calculatePeriod().toFixed(2)} s`;
            DOM.values.frequency.textContent = `${calculateFrequency().toFixed(2)} Hz`;
        }
        
        function updateExplanation() {
            explanationContent.innerHTML = explanations[simulation.currentSim];
        }
        
        function exportData() {
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Tiempo (s),Desplazamiento (m),Velocidad (m/s),Fuerza (N),Energía Potencial (J),Energía Cinética (J),Energía Total (J)\n";
            
            simulation.dataLog.forEach(data => {
                csvContent += `${data.time.toFixed(3)},${data.displacement.toFixed(3)},${data.velocity.toFixed(3)},${data.force.toFixed(3)},${data.potentialEnergy.toFixed(3)},${data.kineticEnergy.toFixed(3)},${data.totalEnergy.toFixed(3)}\n`;
            });
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "datos_elasticidad.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function clearData() {
            simulation.dataLog = [];
            dataTableBody.innerHTML = '';
        }
        
        // =============================================
        // INICIALIZACIÓN
        // =============================================
        
        window.addEventListener('load', function() {
            resizeCanvas();
            setupEventListeners();
            updateExplanation();
            draw();
            
            // Integración con el sistema principal
            if (window.physicsLab) {
                window.currentSimulation = window.elasticitySimulator;
            }
        });
        
        // Manejo de errores global
        window.addEventListener('error', function(e) {
            console.error('Error en el simulador de elasticidad:', e.error);
        });
    </script>
</body>
</html>